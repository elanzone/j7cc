介绍
====

用Java开发一个简单、并发的应用时，一般创建一些 Runnable 对象及对应的 Thread 对象来执行它们。
如果有很多并发任务，此实现方式有以下不足:

* 必须实现所有代码相关信息以管理线程对象（创建、结束、获取结果）
* 每个任务创建一个线程。如果任务数很多，会影响应用的吞吐量
* 必须有效地控制和管理计算机的资源。如果您创建太多线程，您可能耗尽系统资源

从 Java 5 开始，Java concurrency API 提供了帮助解决问题的机制。
此机制为 Executor 框架，包含 Executor 接口、其子接口 ExecutorService 和实现这 2 个接口的 ThreadPoolExecutor 类。

此机制将任务的创建和执行分离。有了一个执行者，您只需要实现 Runnable 对象并交给执行者。
执行者负责它们的执行、实例化并运行于必要的线程。执行者还使用线程池来提高性能。
当您将一个任务交给执行者，执行者尝试使用一个线程池来执行此任务，避免线程的持续生成。

Executor 框架的另一个重要的优势是 Callable 接口。它类似 Runnable 接口，而且提供2个改进，如下:

* 此接口的主要方法是 call()，可以返回结果
* 当您将一个 Callable 对象发给一个 executor，您得到一个实现 Future 接口的对象。
    您可使用此对象来控制 Callable 对象的状态和结果。


